deepdive {

  #sampler.sampler_args: "-l 300 -s 1 -i 500 --alpha 0.1 -c 0"
  #sampler.sampler_args: "-l 0 -s 1 -i 2000 --alpha 0.1 -c 0" #-b 10" # -b 0.1 -b 1 -b 10"
  sampler.sampler_args: "-l 0 -s 1 -i 1000 --alpha 0.1 -c 0" # -b 0.01"
  #sampler.sampler_args: "-l 0 -s 1 -i 10000 --alpha 0.1 -c 0"

  schema.variables {
    #orgs.is_company: Boolean
    #orgprotos.is_proto: Boolean
    orglinks.is_link: Boolean
  }

  pipeline.run: debug 

  pipeline.pipelines {
    #debug = [ extract_preprocess_bodies, extract_preprocess_titles ]
    #debug = [ extract_orgs ]
    #debug = [ extract_orgprotos ]
    #debug = [ extract_orglinks ]
    #debug = [ negative_bias, at_most_one_link, at_least_one_link, link_implies_proto, is_prefix, is_ignorecase_equal ]
    #debug = [ negative_bias, one_link_is_true, link_implies_proto ]#, is_prefix, is_ignorecase_equal ]
    debug = [ one_link_is_true ] # , is_prefix] #, is_ignorecase_equal ]
    #debug = [ entities_context_features ]
    #debug = [ extract_pairs ]
    #debug = [ negative_bias, same_to_same, one_of_n_features, consecutive_in_proximity, city, city_with_hundreds_of_thousands_of_inhabitants, 
    #        city_with_millions_of_inhabitants, boost_countries ] #, context_features ]

    #all = [ extract_preprocess_bodies, extract_preprocess_titles,
    #        extract_orgs, extract_orgprotos, extract_orglinks,
    #        negative_bias, at_most_one_link, at_least_one_link, link_implies_proto, is_prefix, is_ignorecase_equal ]

    
    #preprocess = [ extract_preprocess ]
    #entity_features_only = [ extract_pairs, one_of_n_features, consecutive_in_proximity,
    #  city, city_with_hundreds_of_thousands_of_inhabitants, city_with_millions_of_inhabitants ]
    #all_features = [ extract_pairs, extract_context_features, one_of_n_features, consecutive_in_proximity,
    #all = [ extract_preprocess, extract_pairs, extract_context_features, one_of_n_features, consecutive_in_proximity,
    #  city, city_with_hundreds_of_thousands_of_inhabitants, city_with_millions_of_inhabitants, context_features ]
  }

  db.default {
    driver   : "org.postgresql.Driver"
    url      : "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user     : ${PGUSER}
    password : ${PGPASSWORD}
    dbname   : ${DBNAME}
    host     : ${PGHOST}
    port     : ${PGPORT}
    gphost   : ${GPHOST}
    gpport   : ${GPPORT}
    gppath   : ${GPPATH}
    # start gpfdist server on the machine running the application with
    # `rungpcommand 'gpfdist -d /lfs/raiders4/0/rionda/greenplum_gpfdist-memex -p 9999'`
  }

  calibration.holdout_fraction: 0.075

  extraction.extractors {

    extract_preprocess_bodies: {
        style: json_extractor
        before: psql -h ${PGHOST} -p ${PGPORT} -d ${DBNAME} -f ${APP_HOME}/schemas/sentences.sql
        input: """
                SELECT id,
                  body
                FROM articles_sample
                WHERE NOT BODY IS NULL
                ORDER BY id ASC
               """
        output_relation: sentences
        udf: ${DEEPDIVE_HOME}/examples/nlp_extractor/run.sh -k id -v body -l 100 -t 16 -a "tokenize,ssplit,pos"
    }

    extract_preprocess_titles: {
        style: json_extractor
        before: psql -h ${PGHOST} -p ${PGPORT} -d ${DBNAME} -f ${APP_HOME}/schemas/sentences_titles.sql
        input: """
                SELECT id,
                  title
                FROM articles_sample
                WHERE NOT TITLE IS NULL
                ORDER BY id ASC
               """
        output_relation: sentences_titles
        udf: ${DEEPDIVE_HOME}/examples/nlp_extractor/run.sh -k id -v title -l 100 -t 16 -a "tokenize,ssplit,pos"
    }    

    extract_orgs: {
        style: tsv_extractor
        before: psql -h ${PGHOST} -p ${PGPORT} -d ${DBNAME} -f ${APP_HOME}/schemas/orgs.sql
        input: """
                SELECT a.document_id, a.words, a.poses, b.words FROM
                   (SELECT
                        document_id,
                        array_to_string(array_agg(array_to_string(words, ' ') order by sentence_offset), '|^|') as words,
                        array_to_string(array_agg(array_to_string(pos_tags, ' ') order by sentence_offset), '|^|') as poses                     
                    FROM sentences GROUP BY document_id) a,
                   (SELECT
                        document_id,
                        array_to_string(words, ' ') as words
                    FROM sentences_titles) b
                WHERE a.document_id = b.document_id 
               """       
        output_relation: orgs
        udf: ${APP_HOME}/udf/extract_orgs.py
    }

    # each mention generates a cluster proto
    extract_orgprotos: {
        style: sql_extractor
        before: psql -h ${PGHOST} -p ${PGPORT} -d ${DBNAME} -f ${APP_HOME}/schemas/orgprotos.sql
        sql: """INSERT INTO orgprotos
                SELECT null, mention_id, name, null FROM orgs
               """
        dependencies: [ extract_orgs ]
    }

    # hard-coded weights to encourage clustering
    # document-level entity linking
    extract_orglinks: {
        style: tsv_extractor
        before: psql -h ${PGHOST} -p ${PGPORT} -d ${DBNAME} -f ${APP_HOME}/schemas/orglinks.sql
        input: """
                SELECT
                    document_id,
                    array_to_string(array_agg(mention_id order by sentence_num, mention_num), ' '),
                    array_to_string(array_agg(name order by sentence_num, mention_num), '|^|'),
                    array_to_string(array_agg(w_from order by sentence_num, mention_num), ' '),
                    array_to_string(array_agg(w_to order by sentence_num, mention_num), ' ')
                FROM
                    orgs
                GROUP BY document_id
               """
        output_relation: orglinks
        udf: ${APP_HOME}/udf/extract_orglinks.py
        dependencies: [ extract_orgprotos ]
    }

    # to simplify: run in two phases:
    #   1. document-level clustering and coreference
    #   2. global clustering

    # global: keys agree -> must cluster
    # global: keys don't agree -> must not cluster
    # use context to decide otherwise

  }
  
  inference.factors {
  
    # penalize using too many clusters
    negative_bias {
      input_query: """
        SELECT o.id as "orgprotos.id", o.is_proto as "orgprotos.is_proto"
        FROM orgprotos o
         """
      function: "IsTrue(orgprotos.is_proto)"
      weight: -100
    }

    one_link_is_true {
      input_query = """
        SELECT array_agg(l.id order by l.id) as "orglinks.id", array_agg(l.is_link order by l.id) as "orglinks.is_link"
        FROM orglinks l
        GROUP BY l.mention_id
         """
      function: "OneIsTrue(orglinks.is_link)"
      weight: 3 
    }


    # penalize two links for same mention
    at_most_one_link {
      input_query = """
        SELECT l1.id as "orglinks1.id", l1.is_link as "orglinks1.is_link",
               l2.id as "orglinks2.id", l2.is_link as "orglinks2.is_link"
        FROM orglinks l1, orglinks l2
        WHERE l1.mention_id = l2.mention_id 
        AND NOT l1.proto_mention_id = l2.proto_mention_id;
         """
      function: "And(orglinks1.is_link, orglinks2.is_link)"
      weight: -100
    }

    # reward link
    at_least_one_link {
      input_query = """
        SELECT l.id as "orglinks.id", l.is_link as "orglinks.is_link"
        FROM orglinks l
         """
      function: "IsTrue(orglinks.is_link)"
      weight: 10 
    }

    # reward link for IS_PREFIX
    is_prefix {
      input_query = """
        SELECT l.id as "orglinks.id", l.is_link as "orglinks.is_link"
        FROM orglinks l
        WHERE 'IS_PREFIX' = ANY(l.features)
         """
      function: "IsTrue(orglinks.is_link)"
      weight: 5 
    }

    # reward link for IS_IGNORECASE_EQUAL
    is_ignorecase_equal {
      input_query = """
        SELECT l.id as "orglinks.id", l.is_link as "orglinks.is_link"
        FROM orglinks l
        WHERE 'IS_IGNORECASE_EQUAL' = ANY(l.features)
         """
      function: "IsTrue(orglinks.is_link)"
      weight: 1
    }

    # link implies that proto exists
    link_implies_proto {
      input_query = """
        SELECT l.id as "orglinks.id", l.is_link as "orglinks.is_link",
               p.id as "orgprotos.id", p.is_proto as "orgprotos.is_proto"
        FROM orglinks l, orgprotos p
        WHERE l.proto_mention_id = p.proto_mention_id
         """
      #function: "Imply(orglinks.is_link, orgprotos.is_proto)"
      function: "And(orglinks.is_link, !orgprotos.is_proto)"
      weight: -100
    }

  }
}

